// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package pg

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteSportByID = `-- name: DeleteSportByID :exec
DELETE FROM sports
WHERE id = $1
`

// Query: #28 (custom)
//
// Удаляет спорт по идентификатору.
func (q *Queries) DeleteSportByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSportByID, id)
	return err
}

const deleteSportsmanByID = `-- name: DeleteSportsmanByID :exec
DELETE FROM sportsmen
WHERE id = $1
`

// Query: #21 (custom)
//
// Удаляет спортсмена по ID.
func (q *Queries) DeleteSportsmanByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteSportsmanByID, id)
	return err
}

const getArenaPlaces = `-- name: GetArenaPlaces :many
SELECT
	p.name,
	p.location
FROM places p
JOIN arena_attributes aa ON aa.place_id = p.id
WHERE
	(
		aa.referees_count >= $1
		OR $1 IS NULL
	)
	AND (
		aa.treadmill_length_cm >= $2
		OR $2 IS NULL
	)
`

type GetArenaPlacesParams struct {
	RefereesCount     pgtype.Int2
	TreadmillLengthCm pgtype.Int8
}

type GetArenaPlacesRow struct {
	Name     string
	Location string
}

// Query #1.1
//
// Получить перечень спортивных сооружений указанного типа в целом или
// удовлетворяющих заданным характеристикам (например, стадионы, вмещающие не менее
// указанного числа зрителей).
func (q *Queries) GetArenaPlaces(ctx context.Context, arg GetArenaPlacesParams) ([]GetArenaPlacesRow, error) {
	rows, err := q.db.Query(ctx, getArenaPlaces, arg.RefereesCount, arg.TreadmillLengthCm)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArenaPlacesRow
	for rows.Next() {
		var i GetArenaPlacesRow
		if err := rows.Scan(&i.Name, &i.Location); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClubActiveSportsmenCountsForPeriod = `-- name: GetClubActiveSportsmenCountsForPeriod :many
SELECT
	c.name,
	COUNT(s.id)
FROM clubs c
LEFT JOIN sportsmen s ON s.club_id = c.id
LEFT JOIN participations p ON p.sportsman_id = s.id
LEFT JOIN tournament_sports ts ON ts.id = p.tournament_sport_id
LEFT JOIN tournaments t ON t.id = ts.tournament_id
WHERE t.start_at BETWEEN $1 AND $2
GROUP BY
	c.id,
	c.name
`

type GetClubActiveSportsmenCountsForPeriodParams struct {
	StartAt pgtype.Timestamptz
	EndAt   pgtype.Timestamptz
}

type GetClubActiveSportsmenCountsForPeriodRow struct {
	Name  string
	Count int64
}

// Query #9
//
// Получить перечень спортивных клубов и число спортсменов этих клубов, участвовавших в
// спортивных соревнованиях в течение заданного интервала времени.
func (q *Queries) GetClubActiveSportsmenCountsForPeriod(ctx context.Context, arg GetClubActiveSportsmenCountsForPeriodParams) ([]GetClubActiveSportsmenCountsForPeriodRow, error) {
	rows, err := q.db.Query(ctx, getClubActiveSportsmenCountsForPeriod, arg.StartAt, arg.EndAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClubActiveSportsmenCountsForPeriodRow
	for rows.Next() {
		var i GetClubActiveSportsmenCountsForPeriodRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClubs = `-- name: GetClubs :many
SELECT
	id,
	name
FROM clubs
`

type GetClubsRow struct {
	ID   int64
	Name string
}

// Query: #24 (custom)
//
// Получает все клубы.
func (q *Queries) GetClubs(ctx context.Context) ([]GetClubsRow, error) {
	rows, err := q.db.Query(ctx, getClubs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClubsRow
	for rows.Next() {
		var i GetClubsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCourtPlaces = `-- name: GetCourtPlaces :many
SELECT
	p.name,
	p.location
FROM places p
JOIN court_attributes ca ON ca.place_id = p.id
WHERE
	(
		ca.width_cm >= $1
		OR $1 IS NULL
	)
	AND (
		ca.length_cm >= $2
		OR $2 IS NULL
	)
	AND (
		ca.is_outdoor = $3
		OR $3 IS NULL
	)
`

type GetCourtPlacesParams struct {
	WidthCm   pgtype.Int8
	LengthCm  pgtype.Int8
	IsOutdoor pgtype.Bool
}

type GetCourtPlacesRow struct {
	Name     string
	Location string
}

// Query #1.3
//
// Получить перечень спортивных сооружений указанного типа в целом или
// удовлетворяющих заданным характеристикам (например, стадионы, вмещающие не менее
// указанного числа зрителей).
func (q *Queries) GetCourtPlaces(ctx context.Context, arg GetCourtPlacesParams) ([]GetCourtPlacesRow, error) {
	rows, err := q.db.Query(ctx, getCourtPlaces, arg.WidthCm, arg.LengthCm, arg.IsOutdoor)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCourtPlacesRow
	for rows.Next() {
		var i GetCourtPlacesRow
		if err := rows.Scan(&i.Name, &i.Location); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGymPlaces = `-- name: GetGymPlaces :many
SELECT
	p.name,
	p.location
FROM places p
JOIN gym_attributes ga ON ga.place_id = p.id
WHERE
	(
		ga.trainers_count >= $1
		OR $1 IS NULL
	)
	AND (
		ga.dumbbells_count >= $2
		OR $2 IS NULL
	)
	AND (
		ga.has_bathhouse = $3
		OR $3 IS NULL
	)
`

type GetGymPlacesParams struct {
	TrainersCount  pgtype.Int2
	DumbbellsCount pgtype.Int2
	HasBathhouse   pgtype.Bool
}

type GetGymPlacesRow struct {
	Name     string
	Location string
}

// Query #1.4
//
// Получить перечень спортивных сооружений указанного типа в целом или
// удовлетворяющих заданным характеристикам (например, стадионы, вмещающие не менее
// указанного числа зрителей).
func (q *Queries) GetGymPlaces(ctx context.Context, arg GetGymPlacesParams) ([]GetGymPlacesRow, error) {
	rows, err := q.db.Query(ctx, getGymPlaces, arg.TrainersCount, arg.DumbbellsCount, arg.HasBathhouse)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGymPlacesRow
	for rows.Next() {
		var i GetGymPlacesRow
		if err := rows.Scan(&i.Name, &i.Location); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInactiveSportsmenForPeriod = `-- name: GetInactiveSportsmenForPeriod :many
SELECT
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg
FROM sportsmen sm
WHERE NOT EXISTS (
	SELECT 1
	FROM participations p
	JOIN tournament_sports ts ON ts.id = p.tournament_sport_id
	JOIN tournaments t ON t.id = ts.tournament_id
	WHERE
		t.start_at BETWEEN $1 AND $2
		AND p.sportsman_id = sm.id
)
`

type GetInactiveSportsmenForPeriodParams struct {
	StartAt pgtype.Timestamptz
	EndAt   pgtype.Timestamptz
}

type GetInactiveSportsmenForPeriodRow struct {
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
}

// Query: #11
//
// Получить список спортсменов, не участвовавших ни в каких соревнованиях в течение
// определенного периода времени.
func (q *Queries) GetInactiveSportsmenForPeriod(ctx context.Context, arg GetInactiveSportsmenForPeriodParams) ([]GetInactiveSportsmenForPeriodRow, error) {
	rows, err := q.db.Query(ctx, getInactiveSportsmenForPeriod, arg.StartAt, arg.EndAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInactiveSportsmenForPeriodRow
	for rows.Next() {
		var i GetInactiveSportsmenForPeriodRow
		if err := rows.Scan(
			&i.Name,
			&i.BirthDate,
			&i.HeightCm,
			&i.WeightKg,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizerTournamentCountsForPeriod = `-- name: GetOrganizerTournamentCountsForPeriod :many
SELECT
	o.name,
	o.location,
	COUNT(t.id)
FROM organizers o
LEFT JOIN tournaments t ON t.organizer_id = o.id
GROUP BY
	o.id,
	o.name,
	o.location
`

type GetOrganizerTournamentCountsForPeriodRow struct {
	Name     string
	Location pgtype.Text
	Count    int64
}

// Query: #12
//
// Получить список организаторов соревнований и число проведенных ими соревнований в
// течение определенного периода времени.
func (q *Queries) GetOrganizerTournamentCountsForPeriod(ctx context.Context) ([]GetOrganizerTournamentCountsForPeriodRow, error) {
	rows, err := q.db.Query(ctx, getOrganizerTournamentCountsForPeriod)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizerTournamentCountsForPeriodRow
	for rows.Next() {
		var i GetOrganizerTournamentCountsForPeriodRow
		if err := rows.Scan(&i.Name, &i.Location, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizers = `-- name: GetOrganizers :many
SELECT
	id,
	name,
	location
FROM organizers
ORDER BY name
`

type GetOrganizersRow struct {
	ID       int64
	Name     string
	Location pgtype.Text
}

// Query: #32 (custom)
//
// Получает всех организаторов.
func (q *Queries) GetOrganizers(ctx context.Context) ([]GetOrganizersRow, error) {
	rows, err := q.db.Query(ctx, getOrganizers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrganizersRow
	for rows.Next() {
		var i GetOrganizersRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Location); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlaceTournamentDatesForPeriod = `-- name: GetPlaceTournamentDatesForPeriod :many
SELECT
	p.name,
	p.location,
	ARRAY_AGG(t.start_at)::TIMESTAMPTZ[] as dates
FROM places p
LEFT JOIN tournaments t ON t.place_id = p.id
WHERE t.start_at BETWEEN $1 AND $2
GROUP BY
	p.id,
	p.name,
	p.location
`

type GetPlaceTournamentDatesForPeriodParams struct {
	StartAt pgtype.Timestamptz
	EndAt   pgtype.Timestamptz
}

type GetPlaceTournamentDatesForPeriodRow struct {
	Name     string
	Location string
	Dates    []pgtype.Timestamptz
}

// Query: #13
//
// Получить перечень спортивных сооружений и даты проведения на них соревнований в
// течение определенного периода времени.
func (q *Queries) GetPlaceTournamentDatesForPeriod(ctx context.Context, arg GetPlaceTournamentDatesForPeriodParams) ([]GetPlaceTournamentDatesForPeriodRow, error) {
	rows, err := q.db.Query(ctx, getPlaceTournamentDatesForPeriod, arg.StartAt, arg.EndAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlaceTournamentDatesForPeriodRow
	for rows.Next() {
		var i GetPlaceTournamentDatesForPeriodRow
		if err := rows.Scan(&i.Name, &i.Location, &i.Dates); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrizeWinnersByTournamentID = `-- name: GetPrizeWinnersByTournamentID :many
SELECT
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id AS club_id,
	c.name AS club_name,
	p.rank
FROM sportsmen sm
JOIN clubs c ON c.id = sm.club_id
JOIN participations p ON p.sportsman_id = sm.id
JOIN tournament_sports ts ON ts.id = p.tournament_sport_id
WHERE
	ts.tournament_id = $1
	AND p.rank <= 3
ORDER BY p.rank
`

type GetPrizeWinnersByTournamentIDRow struct {
	ID        int64
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	ClubName  string
	Rank      int16
}

// Query #7
//
// Получить список призеров указанного соревнования.
func (q *Queries) GetPrizeWinnersByTournamentID(ctx context.Context, tournamentID int64) ([]GetPrizeWinnersByTournamentIDRow, error) {
	rows, err := q.db.Query(ctx, getPrizeWinnersByTournamentID, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPrizeWinnersByTournamentIDRow
	for rows.Next() {
		var i GetPrizeWinnersByTournamentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BirthDate,
			&i.HeightCm,
			&i.WeightKg,
			&i.ClubID,
			&i.ClubName,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSportByID = `-- name: GetSportByID :one
SELECT
	id,
	name
FROM sports
WHERE id = $1
`

type GetSportByIDRow struct {
	ID   int64
	Name string
}

// Query: #27 (custom)
//
// Получает спорт по идентификатору.
func (q *Queries) GetSportByID(ctx context.Context, id int64) (GetSportByIDRow, error) {
	row := q.db.QueryRow(ctx, getSportByID, id)
	var i GetSportByIDRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getSports = `-- name: GetSports :many
SELECT
	id,
	name
FROM sports
ORDER BY name
`

type GetSportsRow struct {
	ID   int64
	Name string
}

// Query: #20 (custom)
//
// Получает все виды спорта.
func (q *Queries) GetSports(ctx context.Context) ([]GetSportsRow, error) {
	rows, err := q.db.Query(ctx, getSports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSportsRow
	for rows.Next() {
		var i GetSportsRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSportsBySportsmanID = `-- name: GetSportsBySportsmanID :many
SELECT
	s.id,
	s.name
FROM sports s
JOIN sportsman_sports sms ON sms.sport_id = s.id
WHERE sms.sportsman_id = $1
`

type GetSportsBySportsmanIDRow struct {
	ID   int64
	Name string
}

// Query: #19 (custom)
//
// Получение видов спорта, которыми занимается спортсмен.
func (q *Queries) GetSportsBySportsmanID(ctx context.Context, sportsmanID int64) ([]GetSportsBySportsmanIDRow, error) {
	rows, err := q.db.Query(ctx, getSportsBySportsmanID, sportsmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSportsBySportsmanIDRow
	for rows.Next() {
		var i GetSportsBySportsmanIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSportsmanByID = `-- name: GetSportsmanByID :one
SELECT
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id AS club_id,
	c.name AS club_name
FROM sportsmen sm
JOIN clubs c ON c.id = sm.club_id
WHERE sm.id = $1
GROUP BY
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id,
	c.name
`

type GetSportsmanByIDRow struct {
	ID        int64
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	ClubName  string
}

// Query: #18 (custom)
//
// Получает спортсмена по идентификатору.
func (q *Queries) GetSportsmanByID(ctx context.Context, id int64) (GetSportsmanByIDRow, error) {
	row := q.db.QueryRow(ctx, getSportsmanByID, id)
	var i GetSportsmanByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.BirthDate,
		&i.HeightCm,
		&i.WeightKg,
		&i.ClubID,
		&i.ClubName,
	)
	return i, err
}

const getSportsmen = `-- name: GetSportsmen :many
SELECT
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id AS club_id,
	c.name AS club_name
FROM sportsmen sm
JOIN clubs c ON c.id = sm.club_id
LEFT JOIN sportsman_sports sms ON sms.sportsman_id = sm.id
LEFT JOIN sports s ON s.id = sms.sport_id
GROUP BY
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id,
	c.name
ORDER BY sm.name
`

type GetSportsmenRow struct {
	ID        int64
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	ClubName  string
}

// Query: #22 (custom)
//
// Получает всех спортсменов.
func (q *Queries) GetSportsmen(ctx context.Context) ([]GetSportsmenRow, error) {
	rows, err := q.db.Query(ctx, getSportsmen)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSportsmenRow
	for rows.Next() {
		var i GetSportsmenRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BirthDate,
			&i.HeightCm,
			&i.WeightKg,
			&i.ClubID,
			&i.ClubName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSportsmenBySportID = `-- name: GetSportsmenBySportID :many
SELECT
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id AS club_id,
	c.name AS club_name,
	ss.rank AS rank
FROM sportsmen sm
JOIN clubs c ON c.id = sm.club_id
JOIN sportsman_sports ss ON ss.sportsman_id = sm.id
WHERE
	ss.sport_id = $1
	AND (
		ss.rank >= $2
		OR $2 IS NULL
	)
ORDER BY ss.rank DESC
`

type GetSportsmenBySportIDParams struct {
	SportID int64
	MinRank pgtype.Int2
}

type GetSportsmenBySportIDRow struct {
	ID        int64
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	ClubName  string
	Rank      pgtype.Int2
}

// Query #2
//
// Получить список спортсменов, занимающихся указанным видом спорта в целом либо не
// ниже определенного разряда.
func (q *Queries) GetSportsmenBySportID(ctx context.Context, arg GetSportsmenBySportIDParams) ([]GetSportsmenBySportIDRow, error) {
	rows, err := q.db.Query(ctx, getSportsmenBySportID, arg.SportID, arg.MinRank)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSportsmenBySportIDRow
	for rows.Next() {
		var i GetSportsmenBySportIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BirthDate,
			&i.HeightCm,
			&i.WeightKg,
			&i.ClubID,
			&i.ClubName,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSportsmenByTrainerID = `-- name: GetSportsmenByTrainerID :many
SELECT
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id AS club_id,
	c.name AS club_name,
	ss.rank AS rank
FROM sportsmen sm
JOIN clubs c ON c.id = sm.club_id
JOIN sportsman_sports ss ON ss.sportsman_id = sm.id
JOIN sportsman_sport_trainers sst ON sst.sportsman_sport_id = ss.id
WHERE
	sst.trainer_id = $1
	AND (
		ss.rank >= $2
		OR $2 IS NULL
	)
ORDER BY ss.rank DESC
`

type GetSportsmenByTrainerIDParams struct {
	TrainerID int64
	MinRank   pgtype.Int2
}

type GetSportsmenByTrainerIDRow struct {
	ID        int64
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	ClubName  string
	Rank      pgtype.Int2
}

// Query #3
//
// Получить список спортсменов, тренирующихся у некого тренера в целом либо не ниже
// определенного разряда.
func (q *Queries) GetSportsmenByTrainerID(ctx context.Context, arg GetSportsmenByTrainerIDParams) ([]GetSportsmenByTrainerIDRow, error) {
	rows, err := q.db.Query(ctx, getSportsmenByTrainerID, arg.TrainerID, arg.MinRank)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSportsmenByTrainerIDRow
	for rows.Next() {
		var i GetSportsmenByTrainerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BirthDate,
			&i.HeightCm,
			&i.WeightKg,
			&i.ClubID,
			&i.ClubName,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSportsmenInvolvedInSeveralSports = `-- name: GetSportsmenInvolvedInSeveralSports :many
SELECT
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id AS club_id,
	c.name AS club_name
FROM sportsmen sm
JOIN clubs c ON c.id = sm.club_id
JOIN sportsman_sports sms ON sms.sportsman_id = sm.id
JOIN sports s ON s.id = sms.sport_id
GROUP BY
	sm.id,
	sm.name,
	sm.birth_date,
	sm.height_cm,
	sm.weight_kg,
	c.id,
	c.name
HAVING COUNT(sms.id) > 1
ORDER BY sm.name
`

type GetSportsmenInvolvedInSeveralSportsRow struct {
	ID        int64
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	ClubName  string
}

// Query #4
//
// Получить список спортсменов, занимающихся более чем одним видом спорта с указанием
// этих видов спорта.
func (q *Queries) GetSportsmenInvolvedInSeveralSports(ctx context.Context) ([]GetSportsmenInvolvedInSeveralSportsRow, error) {
	rows, err := q.db.Query(ctx, getSportsmenInvolvedInSeveralSports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSportsmenInvolvedInSeveralSportsRow
	for rows.Next() {
		var i GetSportsmenInvolvedInSeveralSportsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BirthDate,
			&i.HeightCm,
			&i.WeightKg,
			&i.ClubID,
			&i.ClubName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStadiumPlaces = `-- name: GetStadiumPlaces :many
SELECT
	p.name,
	p.location
FROM places p
JOIN stadium_attributes sa ON sa.place_id = p.id
WHERE
	(
		sa.width_cm >= $1
		OR $1 IS NULL
	)
	AND (
		sa.length_cm >= $2
		OR $2 IS NULL
	)
	AND (
		sa.max_spectators >= $3
		OR $3 IS NULL
	)
	AND (
		sa.is_outdoor = $4
		OR $4 IS NULL
	)
	AND (
		sa.coating = $5
		OR $5 IS NULL
	)
`

type GetStadiumPlacesParams struct {
	WidthCm       pgtype.Int8
	LengthCm      pgtype.Int8
	MaxSpectators pgtype.Int2
	IsOutdoor     pgtype.Bool
	Coating       pgtype.Text
}

type GetStadiumPlacesRow struct {
	Name     string
	Location string
}

// Query #1.2
//
// Получить перечень спортивных сооружений указанного типа в целом или
// удовлетворяющих заданным характеристикам (например, стадионы, вмещающие не менее
// указанного числа зрителей).
func (q *Queries) GetStadiumPlaces(ctx context.Context, arg GetStadiumPlacesParams) ([]GetStadiumPlacesRow, error) {
	rows, err := q.db.Query(ctx, getStadiumPlaces,
		arg.WidthCm,
		arg.LengthCm,
		arg.MaxSpectators,
		arg.IsOutdoor,
		arg.Coating,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStadiumPlacesRow
	for rows.Next() {
		var i GetStadiumPlacesRow
		if err := rows.Scan(&i.Name, &i.Location); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournaments = `-- name: GetTournaments :many
SELECT
	t.id,
	t.start_at,
	p.name AS place_name,
	o.name AS organizer_name
FROM tournaments t
JOIN organizers o ON o.id = t.organizer_id
JOIN places p ON p.id = t.place_id
ORDER BY t.id DESC
`

type GetTournamentsRow struct {
	ID            int64
	StartAt       pgtype.Timestamptz
	PlaceName     string
	OrganizerName string
}

// Query: #26 (custom)
//
// Получает все соревнования.
func (q *Queries) GetTournaments(ctx context.Context) ([]GetTournamentsRow, error) {
	rows, err := q.db.Query(ctx, getTournaments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTournamentsRow
	for rows.Next() {
		var i GetTournamentsRow
		if err := rows.Scan(
			&i.ID,
			&i.StartAt,
			&i.PlaceName,
			&i.OrganizerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentsByPlaceID = `-- name: GetTournamentsByPlaceID :many
SELECT
	p.name,
	o.name,
	t.start_at
FROM tournaments t
JOIN places p ON p.id = t.place_id
JOIN organizers o ON o.id = t.organizer_id
JOIN tournament_sports ts ON ts.tournament_id = t.id
WHERE
	t.place_id = $1
	AND (
		ts.sport_id = $2
		OR $2 IS NULL
	)
`

type GetTournamentsByPlaceIDParams struct {
	PlaceID int64
	SportID pgtype.Int8
}

type GetTournamentsByPlaceIDRow struct {
	Name    string
	Name_2  string
	StartAt pgtype.Timestamptz
}

// Query #8
//
// Получить перечень соревнований, проведенных в указанном спортивном сооружении в
// целом либо по определенному виду спорта.
func (q *Queries) GetTournamentsByPlaceID(ctx context.Context, arg GetTournamentsByPlaceIDParams) ([]GetTournamentsByPlaceIDRow, error) {
	rows, err := q.db.Query(ctx, getTournamentsByPlaceID, arg.PlaceID, arg.SportID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTournamentsByPlaceIDRow
	for rows.Next() {
		var i GetTournamentsByPlaceIDRow
		if err := rows.Scan(&i.Name, &i.Name_2, &i.StartAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentsForPeriod = `-- name: GetTournamentsForPeriod :many
SELECT
	t.id,
	t.start_at,
	p.name AS place_name,
	o.name AS organizer_name
FROM tournaments t
JOIN places p ON p.id = t.place_id
JOIN organizers o ON o.id = t.organizer_id
WHERE
	t.start_at BETWEEN $1 AND $2
	AND (
		t.organizer_id = $3
		OR $3 IS NULL
	)
`

type GetTournamentsForPeriodParams struct {
	StartAt     pgtype.Timestamptz
	EndAt       pgtype.Timestamptz
	OrganizerID pgtype.Int8
}

type GetTournamentsForPeriodRow struct {
	ID            int64
	StartAt       pgtype.Timestamptz
	PlaceName     string
	OrganizerName string
}

// Query #6
//
// Получить перечень соревнований, проведенных в течение заданного периода времени в
// целом либо указанным организатором.
func (q *Queries) GetTournamentsForPeriod(ctx context.Context, arg GetTournamentsForPeriodParams) ([]GetTournamentsForPeriodRow, error) {
	rows, err := q.db.Query(ctx, getTournamentsForPeriod, arg.StartAt, arg.EndAt, arg.OrganizerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTournamentsForPeriodRow
	for rows.Next() {
		var i GetTournamentsForPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.StartAt,
			&i.PlaceName,
			&i.OrganizerName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainers = `-- name: GetTrainers :many
SELECT
	id,
	name
FROM trainers
`

type GetTrainersRow struct {
	ID   int64
	Name string
}

// Query: #31 (custom)
//
// Получает всех тренеров.
func (q *Queries) GetTrainers(ctx context.Context) ([]GetTrainersRow, error) {
	rows, err := q.db.Query(ctx, getTrainers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrainersRow
	for rows.Next() {
		var i GetTrainersRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainersBySportID = `-- name: GetTrainersBySportID :many
SELECT DISTINCT
	t.id,
	t.name
FROM trainers t
JOIN sportsman_sport_trainers sst ON sst.trainer_id = t.id
JOIN sportsman_sports ss ON ss.id = sst.sportsman_sport_id
WHERE ss.sport_id = $1
ORDER BY t.name
`

type GetTrainersBySportIDRow struct {
	ID   int64
	Name string
}

// Query #10
//
// Получить список тренеров по определенному виду спорта.
func (q *Queries) GetTrainersBySportID(ctx context.Context, sportID int64) ([]GetTrainersBySportIDRow, error) {
	rows, err := q.db.Query(ctx, getTrainersBySportID, sportID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrainersBySportIDRow
	for rows.Next() {
		var i GetTrainersBySportIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainersBySportsmanID = `-- name: GetTrainersBySportsmanID :many
SELECT
	t.id,
	t.name
FROM trainers t
JOIN sportsman_sport_trainers sst ON sst.trainer_id = t.id
JOIN sportsman_sports ss ON ss.id = sst.sportsman_sport_id
WHERE ss.sportsman_id = $1
`

type GetTrainersBySportsmanIDRow struct {
	ID   int64
	Name string
}

// Query #5
//
// Получить список тренеров указанного спортсмена.
func (q *Queries) GetTrainersBySportsmanID(ctx context.Context, sportsmanID int64) ([]GetTrainersBySportsmanIDRow, error) {
	rows, err := q.db.Query(ctx, getTrainersBySportsmanID, sportsmanID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrainersBySportsmanIDRow
	for rows.Next() {
		var i GetTrainersBySportsmanIDRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertArena = `-- name: InsertArena :exec
WITH
place_type AS (
	SELECT id FROM place_types WHERE attributes_table_name = 'arena_attributes'
),
place AS (
	INSERT INTO places (name, location, type_id)
	VALUES ($3, $4, (SELECT id FROM place_type))
	RETURNING id
)
INSERT INTO arena_attributes (place_id, referees_count, treadmill_length_cm)
VALUES ((SELECT id FROM place), $1, $2)
`

type InsertArenaParams struct {
	RefereesCount     int16
	TreadmillLengthCm int64
	Name              string
	Location          string
}

// Query: #14 (custom)
//
// Создаёт манеж и задаёт для него аттрибуты.
func (q *Queries) InsertArena(ctx context.Context, arg InsertArenaParams) error {
	_, err := q.db.Exec(ctx, insertArena,
		arg.RefereesCount,
		arg.TreadmillLengthCm,
		arg.Name,
		arg.Location,
	)
	return err
}

const insertCourt = `-- name: InsertCourt :exec
WITH
place_type AS (
	SELECT id FROM place_types WHERE attributes_table_name = 'court_attributes'
),
place AS (
	INSERT INTO places (name, location, type_id)
	VALUES ($4, $5, place_type.id)
	RETURNING id
)
INSERT INTO court_attributes (place_id, width_cm, length_cm, is_outdoor)
VALUES ((SELECT id FROM place), $1, $2, $3)
`

type InsertCourtParams struct {
	WidthCm   int64
	LengthCm  int64
	IsOutdoor bool
	Name      string
	Location  string
}

// Query: #16 (custom)
//
// Создаёт корт и задаёт для него аттрибуты.
func (q *Queries) InsertCourt(ctx context.Context, arg InsertCourtParams) error {
	_, err := q.db.Exec(ctx, insertCourt,
		arg.WidthCm,
		arg.LengthCm,
		arg.IsOutdoor,
		arg.Name,
		arg.Location,
	)
	return err
}

const insertGym = `-- name: InsertGym :exec
WITH
place_type AS (
	SELECT id FROM place_types WHERE attributes_table_name = 'gym_attributes'
),
place AS (
	INSERT INTO places (name, location, type_id)
	VALUES ($4, $5, place_type.id)
	RETURNING id
)
INSERT INTO gym_attributes (place_id, trainers_count, dumbbells_count, has_bathhouse)
VALUES ((SELECT id FROM place), $1, $2, $3)
`

type InsertGymParams struct {
	TrainersCount  int16
	DumbbellsCount int16
	HasBathhouse   bool
	Name           string
	Location       string
}

// Query: #17 (custom)
//
// Создаёт зал и задаёт для него аттрибуты.
func (q *Queries) InsertGym(ctx context.Context, arg InsertGymParams) error {
	_, err := q.db.Exec(ctx, insertGym,
		arg.TrainersCount,
		arg.DumbbellsCount,
		arg.HasBathhouse,
		arg.Name,
		arg.Location,
	)
	return err
}

const insertSport = `-- name: InsertSport :exec
INSERT INTO sports (name)
VALUES ($1)
`

// Query: #29 (custom)
//
// Создаёт вид спорта.
func (q *Queries) InsertSport(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, insertSport, name)
	return err
}

const insertSportsman = `-- name: InsertSportsman :exec
WITH sportsman AS (
	INSERT INTO sportsmen (name, birth_date, height_cm, weight_kg, club_id)
	VALUES ($1, $2, $3, $4, $5)
	RETURNING id
)
INSERT INTO sportsman_sports (sportsman_id, sport_id)
SELECT
	id,
	sport_id
FROM
	sportsman,
	UNNEST($6::BIGINT[]) AS sport_id
`

type InsertSportsmanParams struct {
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	SportIds  []int64
}

// Query: #25 (custom)
//
// Создаёт спортсмена.
func (q *Queries) InsertSportsman(ctx context.Context, arg InsertSportsmanParams) error {
	_, err := q.db.Exec(ctx, insertSportsman,
		arg.Name,
		arg.BirthDate,
		arg.HeightCm,
		arg.WeightKg,
		arg.ClubID,
		arg.SportIds,
	)
	return err
}

const insertStadium = `-- name: InsertStadium :exec
WITH
place_type AS (
	SELECT id FROM place_types WHERE attributes_table_name = 'stadium_attributes'
),
place AS (
	INSERT INTO places (name, location, type_id)
	VALUES ($6, $7, place_type.id)
	RETURNING id
)
INSERT INTO stadium_attributes (place_id, width_cm, length_cm, max_spectators, is_outdoor, coating)
VALUES ((SELECT id FROM place), $1, $2, $3, $4, $5)
`

type InsertStadiumParams struct {
	WidthCm       int64
	LengthCm      int64
	MaxSpectators int16
	IsOutdoor     bool
	Coating       string
	Name          string
	Location      string
}

// Query: #15 (custom)
//
// Создаёт стадион и задаёт для него аттрибуты.
func (q *Queries) InsertStadium(ctx context.Context, arg InsertStadiumParams) error {
	_, err := q.db.Exec(ctx, insertStadium,
		arg.WidthCm,
		arg.LengthCm,
		arg.MaxSpectators,
		arg.IsOutdoor,
		arg.Coating,
		arg.Name,
		arg.Location,
	)
	return err
}

const updateSportByID = `-- name: UpdateSportByID :exec
UPDATE sports
SET name = $1
WHERE id = $2
`

type UpdateSportByIDParams struct {
	Name string
	ID   int64
}

// Query: #30 (custom)
//
// Обновляет вид спорта.
func (q *Queries) UpdateSportByID(ctx context.Context, arg UpdateSportByIDParams) error {
	_, err := q.db.Exec(ctx, updateSportByID, arg.Name, arg.ID)
	return err
}

const updateSportsmanByID = `-- name: UpdateSportsmanByID :exec
WITH deleted_sportsman_sport_ids AS (
	DELETE FROM sportsman_sports
	WHERE
		sportsman_id = $1
		AND NOT (sport_id = ANY($7::BIGINT[]))
	RETURNING id
),
inserted_sportsman_sport_ids AS (
	INSERT INTO sportsman_sports (sportsman_id, sport_id)
	SELECT
		$1,
		sport_id
	FROM UNNEST($7::BIGINT[]) AS sport_id
	ON CONFLICT (sportsman_id, sport_id) DO NOTHING
	RETURNING id
)
UPDATE sportsmen AS sm
SET
	name = $2,
	birth_date = $3,
	height_cm = $4,
	weight_kg = $5,
	club_id = $6
WHERE sm.id = $1
`

type UpdateSportsmanByIDParams struct {
	ID        int64
	Name      string
	BirthDate pgtype.Date
	HeightCm  int16
	WeightKg  pgtype.Numeric
	ClubID    int64
	SportIds  []int64
}

// Query: #23 (custom)
//
// Обновляет спортсмена по идентификатору.
func (q *Queries) UpdateSportsmanByID(ctx context.Context, arg UpdateSportsmanByIDParams) error {
	_, err := q.db.Exec(ctx, updateSportsmanByID,
		arg.ID,
		arg.Name,
		arg.BirthDate,
		arg.HeightCm,
		arg.WeightKg,
		arg.ClubID,
		arg.SportIds,
	)
	return err
}
